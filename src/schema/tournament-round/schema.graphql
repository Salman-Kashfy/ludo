type TournamentPlayers {
    uuid: ID!
    phone: String!
    isWinner: Boolean
}

type TournamentTable {
    uuid: ID!
    name: String!
    customers: TournamentPlayers
}

type TournamentRound {
    id: Int!
    uuid: ID!
    tournamentId: Int!
    round: Int!
    playerCount: Int!
    tableCount: Int!
    status: TournamentRoundStatus!
    createdAt: Datetime!
    updatedAt: Datetime!
    startedAt: Datetime
    completedAt: Datetime

    # Relations
    tournament: Tournament
    table: TournamentTable
}

type TournamentRoundAssignment {
    round: Int!
    tableId: Int!
    table: Table
    playerIds: [Int!]!
    entries: [TournamentRound!]!
}

#------------------------
# Queries
#------------------------
extend type Query {
    tournamentRounds(params: TournamentRoundFilter!): TournamentRoundsPayload! @requireAuth @requirePermissions(permissions: ["tournament:view"])
    tournamentAllRounds(tournamentUuid: ID!): TournamentRoundsPayload! @requireAuth @requirePermissions(permissions: ["tournament:view"])
    tournamentRound(tournamentUuid: ID!, round: Int!): GetTournamentRoundPayload! @requireAuth @requirePermissions(permissions: ["tournament:view"])
}

#------------------------
# Mutations
#------------------------
extend type Mutation {
    startTournament(input: StartTournamentInput!): TournamentRoundTransitionPayload! @requireAuth @requirePermissions(permissions: ["tournament:create"])
    completeTournamentRound(input: CompleteTournamentRoundInput!): CompleteTournamentRoundPayload! @requireAuth @requirePermissions(permissions: ["tournament:create"])
    startNextTournamentRound(input: StartNextTournamentRoundInput!): TournamentRoundTransitionPayload! @requireAuth @requirePermissions(permissions: ["tournament:create"])
}

input TournamentRoundFilter {
    tournamentUuid: ID!
    round: Int!
}

input StartTournamentInput {
    tournamentUuid: ID!
    randomize: Boolean
}

input CompleteTournamentRoundInput {
    tournamentUuid: ID!
    round: Int
    winnerCustomerIds: [Int!]!
}

input StartNextTournamentRoundInput {
    tournamentUuid: ID!
    randomize: Boolean
}

type TournamentRoundPayload {
    status: Boolean
    data: TournamentRound
    errors: [GlobalError]
    errorMessage: String
}

type TournamentRoundsPayload {
    list: [TournamentRound]
}

type TournamentRoundTransitionPayload {
    data: TournamentRoundTransition
    errors: [GlobalError]
    status: Boolean
    errorMessage: String
}

type TournamentRoundTransition {
    tournament: Tournament
    round: TournamentRound
    uuid: ID
    status: TournamentStatus
    currentRound: Int
    startedAt: Datetime
}

type TournamentRoundWinner {
    id: Int!
    tournamentId: Int!
    customerId: Int!
    tableId: Int
    round: Int!
    isWinner: Boolean!
    createdAt: Datetime!
    customer: Customer
    table: Table
}

type CompleteTournamentRoundPayload {
    status: Boolean
    tournament: Tournament
    winners: [TournamentRoundWinner!]!
    errors: [GlobalError]
    errorMessage: String
}

type TournamentRoundTable {
    tableId: Int
    table: Table
    players: [TournamentRoundTablePlayer!]!
}

type TournamentRoundTablePlayer {
    id: Int!
    customerId: Int!
    customerUuid: ID!
    isWinner: Boolean!
    customer: Customer
}

type GetTournamentRoundData {
    round: TournamentRound!
    tables: [TournamentRoundTable!]!
}

type GetTournamentRoundPayload {
    status: Boolean
    data: GetTournamentRoundData
    errors: [GlobalError]
    errorMessage: String
}

enum TournamentRoundStatus {
    UPCOMING
    ACTIVE
    COMPLETED
    CANCELLED
}